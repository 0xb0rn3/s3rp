#!/bin/bash

# ==============================================================================
# S3RP UNIFIED RED TEAM FRAMEWORK - SAMPLE PRACTICAL FRAMEWORK!
# Author: oxbv1 | 0xb0rn3
# ==============================================================================
# This framework combines all the functionality from scan01 through scan09,
# plus additional features and improvements. Every function is modular and
# can be copied to build your own custom toolkit.
# ==============================================================================

# ============================================
# SECTION 1: COLOR DEFINITIONS
# ============================================
RED='\033[1;31m'
GRN='\033[1;32m'
YEL='\033[1;33m'
BLU='\033[0;34m'
CYN='\033[0;36m'
WHT='\033[1;37m'
DGRY='\033[1;30m'
NC='\033[0m'

# ============================================
# SECTION 2: GLOBAL CONFIGURATION
# ============================================
FRAMEWORK_VERSION="2.0"
OPERATION_PREFIX="s3rp_OP"
DEFAULT_TIMING="-T4"
DEFAULT_MIN_RATE="500"
PROXY_CMD="proxychains4 -q"

# Directory structure
MSF_RESOURCE_DIR="metasploit_resources"
WEB_DISCOVERY_DIR="web_discovery"
RECON_DIR="recon"
EXPLOIT_DIR="exploitation"
LOG_DIR="logs"
REPORT_DIR="reports"

# Feature flags
ENABLE_PROXY=false
ENABLE_WEB_ENUM=true
ENABLE_EXPLOIT_SEARCH=true
ENABLE_MSF_INTEGRATION=true

# ============================================
# SECTION 3: SIGNAL HANDLING
# ============================================
trap cleanup_on_interrupt INT TERM

cleanup_on_interrupt() {
    echo -e "\n${YEL}[!] Interrupt received. Cleaning up...${NC}"
    jobs -p | xargs -r kill 2>/dev/null
    if [ -n "$SESSION_DIR" ] && [ -d "$SESSION_DIR" ]; then
        echo "$(date): Session interrupted" >> "$SESSION_DIR/$LOG_DIR/session.log"
        echo -e "${CYN}[*] Session data preserved: $SESSION_DIR${NC}"
    fi
    echo -e "${RED}[!] Framework terminated${NC}"
    exit 130
}

# ============================================
# SECTION 4: BANNER
# ============================================
show_banner() {
    clear
    echo -e "${RED}"
    echo "  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— "
    echo "  â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—"
    echo "  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•"
    echo "  â•šâ•â•â•â•â–ˆâ–ˆâ•‘ â•šâ•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â• "
    echo "  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     "
    echo "  â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•     "
    echo -e "${WHT}      [ UNIFIED RED TEAM FRAMEWORK v${FRAMEWORK_VERSION} ]${NC}"
    echo -e "${CYN}      [ DEVELOPER: oxbv1 | 0xb0rn3 ]${NC}"
    echo -e "${CYN}      [ AI-ASSISTED: Google Gemini ]${NC}"
    echo "=========================================================="
    echo ""
}

# ============================================
# SECTION 5: PRIVILEGE CHECK
# ============================================
check_privileges() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}[!] Root privileges required${NC}"
        echo -e "${YEL}[*] Run with: sudo $0${NC}"
        exit 1
    fi
}

# ============================================
# SECTION 6: DEPENDENCY MANAGEMENT
# ============================================
check_dependencies() {
    echo -e "${CYN}[*] Checking dependencies...${NC}"
    
    local required=("nmap" "grep" "awk" "sed")
    local enhanced=("searchsploit" "gobuster" "xsltproc")
    local optional=("msfconsole" "proxychains4" "masscan" "nikto")
    
    local missing_required=()
    local missing_enhanced=()
    
    for tool in "${required[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            missing_required+=("$tool")
        fi
    done
    
    for tool in "${enhanced[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            missing_enhanced+=("$tool")
        fi
    done
    
    if [ ${#missing_required[@]} -ne 0 ]; then
        echo -e "${RED}[!] Missing required: ${missing_required[*]}${NC}"
        read -p "Install? (y/n): " response
        [[ "$response" == "y" ]] && install_dependencies "${missing_required[@]}"
    fi
    
    if [ ${#missing_enhanced[@]} -ne 0 ]; then
        echo -e "${YEL}[!] Missing enhanced: ${missing_enhanced[@]}${NC}"
        echo -e "${YEL}[*] Some features will be limited${NC}"
    fi
    
    echo -e "${GRN}[âœ“] Dependency check complete${NC}"
}

install_dependencies() {
    local tools=("$@")
    if [ -f /etc/debian_version ]; then
        apt-get update -qq && apt-get install -y "${tools[@]}"
    elif [ -f /etc/redhat-release ]; then
        dnf install -y "${tools[@]}"
    elif [ -f /etc/arch-release ]; then
        pacman -S --noconfirm "${tools[@]}"
    else
        echo -e "${RED}[!] Unknown system. Install manually: ${tools[*]}${NC}"
        exit 1
    fi
}

# ============================================
# SECTION 7: NETWORK INTERFACE DETECTION & SELECTION
# ============================================
# This function detects available network interfaces and allows the user
# to select which interface to use for scanning. Critical for:
# - Multi-homed systems (multiple network cards)
# - VPN scenarios (choosing VPN interface vs physical)
# - Wireless pentesting (selecting monitor mode interface)
# - Container/VM environments (bridge vs host networking)
#
# Modify this to: Add interface validation, speed testing, automatic
# selection based on target network, or integration with VPN management.

detect_interfaces() {
    echo -e "\n${CYN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYN}â•‘   NETWORK INTERFACE DETECTION  â•‘${NC}"
    echo -e "${CYN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    # Get all active network interfaces (excluding loopback)
    local interfaces=()
    local interface_details=()
    
    # Use ip command (modern) or fall back to ifconfig (legacy)
    if command -v ip &> /dev/null; then
        while IFS= read -r line; do
            local iface=$(echo "$line" | awk '{print $2}' | tr -d ':')
            local state=$(echo "$line" | grep -o "state [A-Z]*" | awk '{print $2}')
            
            # Skip loopback
            [[ "$iface" == "lo" ]] && continue
            
            # Get IP address
            local ip_addr=$(ip addr show "$iface" | grep "inet " | awk '{print $2}' | cut -d'/' -f1 | head -1)
            [[ -z "$ip_addr" ]] && ip_addr="No IP"
            
            # Get MAC address
            local mac_addr=$(ip link show "$iface" | grep "link/ether" | awk '{print $2}')
            [[ -z "$mac_addr" ]] && mac_addr="No MAC"
            
            interfaces+=("$iface")
            interface_details+=("$iface|$state|$ip_addr|$mac_addr")
        done < <(ip link show | grep -E "^[0-9]+:")
    elif command -v ifconfig &> /dev/null; then
        while IFS= read -r iface; do
            [[ "$iface" == "lo" ]] && continue
            
            local ip_addr=$(ifconfig "$iface" | grep "inet " | awk '{print $2}')
            [[ -z "$ip_addr" ]] && ip_addr="No IP"
            
            local mac_addr=$(ifconfig "$iface" | grep "ether" | awk '{print $2}')
            [[ -z "$mac_addr" ]] && mac_addr="No MAC"
            
            interfaces+=("$iface")
            interface_details+=("$iface|UP|$ip_addr|$mac_addr")
        done < <(ifconfig -a | grep -E "^[a-z]" | awk '{print $1}' | tr -d ':')
    else
        echo -e "${RED}[!] No network tools available (ip or ifconfig)${NC}"
        SELECTED_INTERFACE=""
        return 1
    fi
    
    # Display interfaces
    if [ ${#interfaces[@]} -eq 0 ]; then
        echo -e "${RED}[!] No active network interfaces found${NC}"
        SELECTED_INTERFACE=""
        return 1
    fi
    
    echo -e "${WHT}Available Network Interfaces:${NC}\n"
    echo -e "${DGRY}$(printf '%-4s %-15s %-10s %-18s %-20s' "No." "Interface" "State" "IP Address" "MAC Address")${NC}"
    echo -e "${DGRY}$(printf '%.0sâ”€' {1..70})${NC}"
    
    local index=1
    for detail in "${interface_details[@]}"; do
        IFS='|' read -r iface state ip mac <<< "$detail"
        
        # Color code by state
        local state_color="${YEL}"
        [[ "$state" == "UP" ]] && state_color="${GRN}"
        
        # Highlight common interface types
        local iface_color="${WHT}"
        [[ "$iface" =~ ^eth ]] && iface_color="${CYN}"    # Ethernet
        [[ "$iface" =~ ^wlan ]] && iface_color="${YEL}"   # Wireless
        [[ "$iface" =~ ^tun ]] && iface_color="${GRN}"    # VPN
        [[ "$iface" =~ ^tap ]] && iface_color="${GRN}"    # VPN
        
        printf "${DGRY}%-4s${NC} ${iface_color}%-15s${NC} ${state_color}%-10s${NC} %-18s %-20s\n" \
            "[$index]" "$iface" "$state" "$ip" "$mac"
        
        ((index++))
    done
    
    echo ""
    
    # Auto-select if only one interface
    if [ ${#interfaces[@]} -eq 1 ]; then
        SELECTED_INTERFACE="${interfaces[0]}"
        echo -e "${GRN}[âœ“] Auto-selected: $SELECTED_INTERFACE${NC}"
        return 0
    fi
    
    # Manual selection
    echo -e "${YEL}[?] Select interface for scanning:${NC}"
    echo -e "    ${DGRY}[A] Auto-detect (use default route)${NC}"
    echo -e "    ${DGRY}[M] Manual specification${NC}"
    echo -e "    ${DGRY}[S] Skip (let nmap decide)${NC}"
    read -p "Selection [1-${#interfaces[@]}/A/M/S]: " iface_choice
    
    case "$iface_choice" in
        [Aa])
            # Use interface of default route
            if command -v ip &> /dev/null; then
                SELECTED_INTERFACE=$(ip route | grep default | awk '{print $5}' | head -1)
            else
                SELECTED_INTERFACE=$(route -n | grep "^0.0.0.0" | awk '{print $NF}' | head -1)
            fi
            [[ -z "$SELECTED_INTERFACE" ]] && SELECTED_INTERFACE="${interfaces[0]}"
            echo -e "${GRN}[âœ“] Auto-selected: $SELECTED_INTERFACE${NC}"
            ;;
        [Mm])
            read -p "Enter interface name: " SELECTED_INTERFACE
            # Validate it exists
            if ! ip link show "$SELECTED_INTERFACE" &>/dev/null && ! ifconfig "$SELECTED_INTERFACE" &>/dev/null; then
                echo -e "${RED}[!] Interface not found, using default${NC}"
                SELECTED_INTERFACE=""
            fi
            ;;
        [Ss])
            SELECTED_INTERFACE=""
            echo -e "${CYN}[*] Skipped - nmap will auto-select${NC}"
            ;;
        *)
            # Numeric selection
            if [[ "$iface_choice" =~ ^[0-9]+$ ]] && [ "$iface_choice" -ge 1 ] && [ "$iface_choice" -le ${#interfaces[@]} ]; then
                SELECTED_INTERFACE="${interfaces[$((iface_choice-1))]}"
                echo -e "${GRN}[âœ“] Selected: $SELECTED_INTERFACE${NC}"
            else
                echo -e "${RED}[!] Invalid selection, using default${NC}"
                SELECTED_INTERFACE="${interfaces[0]}"
            fi
            ;;
    esac
    
    # Log selection
    if [ -n "$SELECTED_INTERFACE" ]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Interface selected: $SELECTED_INTERFACE" >> "$SESSION_DIR/$LOG_DIR/session.log" 2>/dev/null
    fi
}

# ============================================
# SECTION 8: PROXY LAYER CHECK
# ============================================
check_proxy_layer() {
    echo -ne "${CYN}[*] Checking anonymity layer... ${NC}"
    
    if command -v proxychains4 &> /dev/null; then
        if [ -f /etc/proxychains4.conf ]; then
            if grep -q "^[^#]*socks\|^[^#]*http" /etc/proxychains4.conf; then
                echo -e "${GRN}[ACTIVE]${NC}"
                ENABLE_PROXY=true
                return 0
            fi
        fi
    fi
    
    echo -e "${RED}[DISABLED]${NC}"
    ENABLE_PROXY=false
}

# ============================================
# SECTION 9: SESSION INITIALIZATION
# ============================================
initialize_session() {
    SESSION_DIR="${OPERATION_PREFIX}_$(date +%Y%m%d_%H%M%S)"
    
    echo -e "${CYN}[*] Initializing session: $SESSION_DIR${NC}"
    
    mkdir -p "$SESSION_DIR"/{$RECON_DIR,$WEB_DISCOVERY_DIR,$EXPLOIT_DIR,$LOG_DIR,$REPORT_DIR,$MSF_RESOURCE_DIR}
    
    cat > "$SESSION_DIR/session_info.txt" <<EOF
Session ID: $SESSION_DIR
Framework Version: $FRAMEWORK_VERSION
Start Time: $(date '+%Y-%m-%d %H:%M:%S')
Operator: $(whoami)
System: $(uname -a)
Proxy Enabled: $ENABLE_PROXY
Network Interface: ${SELECTED_INTERFACE:-Auto-detect}
EOF
    
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Session initialized" >> "$SESSION_DIR/$LOG_DIR/session.log"
    echo -e "${GRN}[âœ“] Session initialized${NC}"
}

# ============================================
# SECTION 9: TARGET CONFIGURATION
# ============================================
configure_target() {
    echo -e "\n${YEL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${YEL}â•‘   TARGET ACQUISITION           â•‘${NC}"
    echo -e "${YEL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo "1. Single Host (IP/hostname)"
    echo "2. Network Range (CIDR)"
    echo "3. Import from file"
    echo "4. Multiple targets"
    read -p "Selection [1-4]: " target_option
    
    case $target_option in
        1|2)
            read -p "Enter target: " TARGET
            echo "$TARGET" > "$SESSION_DIR/targets.txt"
            ;;
        3)
            read -p "Enter file path: " target_file
            if [ -f "$target_file" ]; then
                cp "$target_file" "$SESSION_DIR/targets.txt"
                TARGET="-iL $SESSION_DIR/targets.txt"
            else
                echo -e "${RED}[!] File not found${NC}"
                configure_target
                return
            fi
            ;;
        4)
            read -p "Enter targets (space-separated): " targets
            echo "$targets" | tr ' ' '\n' > "$SESSION_DIR/targets.txt"
            TARGET="-iL $SESSION_DIR/targets.txt"
            ;;
        *)
            configure_target
            return
            ;;
    esac
    
    echo -e "${GRN}[âœ“] Target configured: $TARGET${NC}"
}

# ============================================
# SECTION 10: SCAN PROFILES
# ============================================
select_scan_profile() {
    echo -e "\n${YEL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${YEL}â•‘   ENGAGEMENT PROFILE           â•‘${NC}"
    echo -e "${YEL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo -e "1. ${CYN}Ghost Mode${NC} - Maximum stealth"
    echo -e "2. ${BLU}Balanced Recon${NC} - Standard scan"
    echo -e "3. ${YEL}Quick Survey${NC} - Fast assessment"
    echo -e "4. ${RED}Vulnerability Hunt${NC} - Deep inspection"
    echo -e "5. ${WHT}Total Infrastructure${NC} - Comprehensive"
    echo -e "6. ${GRN}Custom${NC} - Manual configuration"
    read -p "Selection [1-6]: " profile
    
    case $profile in
        1)
            SCAN_FLAGS="-sS -Pn -f --mtu 8 -g 53 -D RND:10 --data-length 32"
            TIMING="-T2"
            NSE_SCRIPTS="--script=banner,firewalk"
            PROFILE_NAME="Ghost_Mode"
            ;;
        2)
            SCAN_FLAGS="-sS -sV -O --version-intensity 5"
            TIMING="-T4"
            NSE_SCRIPTS="--script=default,safe,discovery"
            PROFILE_NAME="Balanced_Recon"
            ;;
        3)
            SCAN_FLAGS="-sS -sV --top-ports 1000"
            TIMING="-T5"
            NSE_SCRIPTS="--script=banner"
            PROFILE_NAME="Quick_Survey"
            ;;
        4)
            SCAN_FLAGS="-sV --version-all -O --osscan-guess"
            TIMING="-T4"
            NSE_SCRIPTS="--script=vuln,exploit,auth,brute"
            PROFILE_NAME="Vuln_Hunt"
            ;;
        5)
            SCAN_FLAGS="-p- -A -sV --version-intensity 9"
            TIMING="-T4"
            NSE_SCRIPTS="--script=default,safe,discovery,vuln"
            PROFILE_NAME="Total_Infrastructure"
            ;;
        6)
            read -p "Enter nmap flags: " SCAN_FLAGS
            read -p "Timing [0-5, default 4]: " custom_timing
            TIMING="-T${custom_timing:-4}"
            read -p "NSE scripts (optional): " custom_scripts
            NSE_SCRIPTS="${custom_scripts:+--script=$custom_scripts}"
            PROFILE_NAME="Custom"
            ;;
    esac
    
    echo -e "${GRN}[âœ“] Profile: $PROFILE_NAME${NC}"
}

# ============================================
# SECTION 11: CORE SCANNING ENGINE
# ============================================
execute_scan() {
    local output_base="$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}"
    
    echo -e "\n${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘   SCAN EXECUTION               â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo -e "${CYN}[*] Target: $TARGET${NC}"
    echo -e "${CYN}[*] Profile: $PROFILE_NAME${NC}"
    echo -e "${CYN}[*] Interface: ${SELECTED_INTERFACE:-Auto-detect}${NC}"
    echo -e "${CYN}[*] Proxy: $([ "$ENABLE_PROXY" = true ] && echo "Enabled" || echo "Disabled")${NC}\n"
    
    local nmap_cmd="nmap -n -Pn --open --stats-every 30s --min-rate $DEFAULT_MIN_RATE"
    nmap_cmd="$nmap_cmd $TIMING $SCAN_FLAGS $NSE_SCRIPTS $TARGET -oA $output_base"
    
    # Add interface specification if selected
    if [ -n "$SELECTED_INTERFACE" ]; then
        nmap_cmd="$nmap_cmd -e $SELECTED_INTERFACE"
        echo -e "${GRN}[âœ“] Using interface: $SELECTED_INTERFACE${NC}"
    fi
    
    [ "$ENABLE_PROXY" = true ] && nmap_cmd="$PROXY_CMD $nmap_cmd"
    
    echo "$nmap_cmd" > "$SESSION_DIR/$LOG_DIR/scan_command.log"
    
    echo -e "${YEL}[!] Executing scan...${NC}\n"
    
    eval "$nmap_cmd" 2>&1 | grep -vE "Starting Nmap|Nmap done|tcpwrapped" | tee "$SESSION_DIR/$LOG_DIR/scan_output.log"
    
    echo -e "\n${GRN}[âœ“] Scan complete${NC}"
    
    if command -v xsltproc &> /dev/null && [ -f "${output_base}.xml" ]; then
        xsltproc "${output_base}.xml" -o "${output_base}.html" 2>/dev/null
    fi
    
    parse_scan_results "$output_base"
}

# ============================================
# SECTION 12: RESULTS PARSER
# ============================================
parse_scan_results() {
    local scan_base=$1
    local gnmap_file="${scan_base}.gnmap"
    
    [ ! -f "$gnmap_file" ] && return
    
    echo -e "\n${WHT}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${WHT}â•‘   SCAN RESULTS SUMMARY         â•‘${NC}"
    echo -e "${WHT}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    local live_hosts=$(grep -c "Status: Up" "$gnmap_file")
    echo -e "${GRN}Live Hosts: $live_hosts${NC}\n"
    
    grep "Ports:" "$gnmap_file" | while IFS= read -r line; do
        local host=$(echo "$line" | awk '{print $2}')
        echo -e "${GRN}$host${NC}"
        
        echo "$line" | grep -oP '\d+/open/[^/]+//[^/]+/[^/]*/' | while IFS= read -r port_info; do
            local port=$(echo "$port_info" | cut -d'/' -f1)
            local service=$(echo "$port_info" | cut -d'/' -f5)
            
            if [[ "$port" =~ ^(21|22|23|80|443|445|3306|3389|8080)$ ]]; then
                echo -e "  ${RED}â†’ $port${NC}/${YEL}$service${NC}"
            else
                echo -e "  ${CYN}â†’ $port${NC}/$service"
            fi
        done
        echo ""
    done
    
    grep "Ports:" "$gnmap_file" > "$SESSION_DIR/$RECON_DIR/parsed_ports.txt"
}

# ============================================
# SECTION 13: WEB ENUMERATION
# ============================================
enumerate_web_services() {
    [ "$ENABLE_WEB_ENUM" != true ] && return
    
    local scan_results="$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.nmap"
    [ ! -f "$scan_results" ] && return
    
    echo -e "\n${YEL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${YEL}â•‘   WEB SERVICE ENUMERATION      â•‘${NC}"
    echo -e "${YEL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    local web_ports=$(grep -E "80/open|443/open|8080/open|8443/open" "$scan_results")
    [ -z "$web_ports" ] && { echo -e "${CYN}[*] No web services detected${NC}"; return; }
    
    ! command -v gobuster &> /dev/null && return
    
    local wordlist="/usr/share/wordlists/dirb/common.txt"
    [ ! -f "$wordlist" ] && wordlist="/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt"
    [ ! -f "$wordlist" ] && { echo -e "${RED}[!] No wordlist found${NC}"; return; }
    
    echo "$web_ports" | while IFS= read -r line; do
        local port=$(echo "$line" | awk '{print $1}' | cut -d'/' -f1)
        local proto="http"
        [[ "$port" =~ ^(443|8443)$ ]] && proto="https"
        
        local url="${proto}://${TARGET}:${port}"
        echo -e "${CYN}[*] Enumerating: $url${NC}"
        
        local output_file="$SESSION_DIR/$WEB_DISCOVERY_DIR/gobuster_port_${port}.txt"
        local gobuster_cmd="gobuster dir -u \"$url\" -w \"$wordlist\" -t 50 -k -q -o \"$output_file\""
        
        [ "$ENABLE_PROXY" = true ] && gobuster_cmd="$PROXY_CMD $gobuster_cmd"
        
        eval "$gobuster_cmd" 2>/dev/null &
    done
    
    wait
    echo -e "\n${GRN}[âœ“] Web enumeration complete${NC}"
}

# ============================================
# SECTION 14: EXPLOIT RESEARCH
# ============================================
search_exploits() {
    [ "$ENABLE_EXPLOIT_SEARCH" != true ] && return
    
    local scan_xml="$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.xml"
    [ ! -f "$scan_xml" ] && return
    
    ! command -v searchsploit &> /dev/null && return
    
    echo -e "\n${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘   EXPLOIT RESEARCH             â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    local exploit_file="$SESSION_DIR/$EXPLOIT_DIR/exploits_found.txt"
    searchsploit --nmap "$scan_xml" > "$exploit_file" 2>/dev/null
    
    if [ -s "$exploit_file" ]; then
        echo -e "${RED}[!] POTENTIAL EXPLOITS IDENTIFIED${NC}\n"
        cat "$exploit_file" | head -20
        echo -e "\n${GRN}[âœ“] Full list: $exploit_file${NC}"
    else
        echo -e "${CYN}[*] No public exploits found${NC}"
    fi
}

# ============================================
# SECTION 15: METASPLOIT INTEGRATION
# ============================================
generate_msf_resource() {
    [ "$ENABLE_MSF_INTEGRATION" != true ] && return
    
    local scan_xml="$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.xml"
    [ ! -f "$scan_xml" ] && return
    
    local rc_file="$SESSION_DIR/$MSF_RESOURCE_DIR/auto_setup.rc"
    
    echo -e "\n${WHT}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${WHT}â•‘   METASPLOIT INTEGRATION       â•‘${NC}"
    echo -e "${WHT}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    cat > "$rc_file" <<EOF
spool $SESSION_DIR/$LOG_DIR/msf_console.log
workspace -a s3rp_$(basename "$SESSION_DIR")
db_import $scan_xml
hosts
services
vulns

# Suggested exploit modules:
EOF
    
    local exploit_file="$SESSION_DIR/$EXPLOIT_DIR/exploits_found.txt"
    if [ -f "$exploit_file" ]; then
        grep "exploits/remote/" "$exploit_file" | awk '{print "# use exploit" substr($NF, index($NF, "/"))}' | sed 's/\.rb//' >> "$rc_file"
    fi
    
    cat >> "$rc_file" <<'EOF'

# Reverse shell handler template:
# use exploit/multi/handler
# set PAYLOAD windows/x64/meterpreter/reverse_tcp
# set LHOST <YOUR_IP>
# set LPORT 4444
# set ExitOnSession false
# exploit -j -z
EOF
    
    echo -e "${GRN}[âœ“] Resource file: $rc_file${NC}"
    echo -e "${CYN}[*] Launch: msfconsole -r $rc_file${NC}"
}

# ============================================
# SECTION 16: VULNERABILITY ASSESSMENT
# ============================================
assess_vulnerabilities() {
    local scan_file="$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.nmap"
    [ ! -f "$scan_file" ] && return
    
    echo -e "\n${YEL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${YEL}â•‘   VULNERABILITY ASSESSMENT     â•‘${NC}"
    echo -e "${YEL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    local findings=()
    local critical=()
    
    # SMB signing check
    if grep -q "smb-security-mode" "$scan_file"; then
        if grep -A10 "smb-security-mode" "$scan_file" | grep -q "Message signing enabled but not required"; then
            critical+=("SMB signing not enforced - relay attacks possible")
        fi
    fi
    
    # Anonymous FTP
    grep -q "Anonymous FTP login allowed" "$scan_file" && findings+=("Anonymous FTP enabled")
    
    # Weak SSL/TLS
    if grep -q "SSLv2\|SSLv3\|TLSv1\.0" "$scan_file"; then
        critical+=("Weak SSL/TLS protocols detected")
    fi
    
    # Default credentials
    grep -q "http-default-accounts\|default login" "$scan_file" && critical+=("Default credentials detected")
    
    # Exposed databases
    grep -qE "3306/open|5432/open|1433/open|27017/open" "$scan_file" && findings+=("Database ports exposed")
    
    # RDP exposure
    grep -q "3389/open" "$scan_file" && findings+=("RDP exposed")
    
    # Telnet
    grep -q "23/open" "$scan_file" && critical+=("Telnet service detected")
    
    if [ ${#critical[@]} -gt 0 ]; then
        echo -e "${RED}[!] CRITICAL FINDINGS:${NC}"
        printf '%s\n' "${critical[@]}" | sed 's/^/  ðŸ”´ /'
        echo ""
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        echo -e "${YEL}[!] FINDINGS:${NC}"
        printf '%s\n' "${findings[@]}" | sed 's/^/  âš ï¸  /'
        echo ""
    fi
    
    [ ${#critical[@]} -eq 0 ] && [ ${#findings[@]} -eq 0 ] && echo -e "${GRN}[âœ“] No obvious vulnerabilities${NC}\n"
}

# ============================================
# SECTION 17: FINAL REPORT
# ============================================
generate_final_report() {
    local report_file="$SESSION_DIR/$REPORT_DIR/engagement_report.txt"
    
    echo -e "\n${WHT}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${WHT}â•‘   GENERATING REPORT            â•‘${NC}"
    echo -e "${WHT}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    cat > "$report_file" <<EOF
================================================================================
                  S3RP FRAMEWORK - ENGAGEMENT REPORT
================================================================================

SESSION INFORMATION
-------------------
Session ID:        $(basename "$SESSION_DIR")
Framework Version: $FRAMEWORK_VERSION
Target:            $TARGET
Profile:           $PROFILE_NAME
Start Time:        $(grep "Start Time" "$SESSION_DIR/session_info.txt" | cut -d: -f2-)
End Time:          $(date '+%Y-%m-%d %H:%M:%S')
Operator:          $(whoami)

SCAN CONFIGURATION
------------------
Flags:             $SCAN_FLAGS
Timing:            $TIMING
NSE Scripts:       $NSE_SCRIPTS
Proxy:             $([ "$ENABLE_PROXY" = true ] && echo "Enabled" || echo "Disabled")

RESULTS
-------
EOF
    
    if [ -f "$SESSION_DIR/$RECON_DIR/parsed_ports.txt" ]; then
        cat "$SESSION_DIR/$RECON_DIR/parsed_ports.txt" >> "$report_file"
    fi
    
    cat >> "$report_file" <<EOF

ARTIFACTS
---------
Scan Results:  $SESSION_DIR/$RECON_DIR/
Web Discovery: $SESSION_DIR/$WEB_DISCOVERY_DIR/
Exploits:      $SESSION_DIR/$EXPLOIT_DIR/
MSF Resources: $SESSION_DIR/$MSF_RESOURCE_DIR/
Reports:       $SESSION_DIR/$REPORT_DIR/

================================================================================
Report generated by s3rp Framework v${FRAMEWORK_VERSION}
Developer: oxbv1 | 0xb0rn3 (AI-assisted with Google Gemini)
Generated: $(date '+%Y-%m-%d %H:%M:%S')
================================================================================
EOF
    
    echo -e "${GRN}[âœ“] Report: $report_file${NC}\n"
    
    echo -e "${WHT}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GRN}          OPERATION COMPLETE${NC}"
    echo -e "${WHT}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "\n${CYN}Session:${NC} $SESSION_DIR"
    echo -e "${CYN}Report:${NC}  $report_file\n"
}

# ============================================
# SECTION 18: MAIN EXECUTION
# ============================================
main() {
    show_banner
    
    echo -e "${CYN}[*] Running pre-flight checks...${NC}\n"
    check_privileges
    check_dependencies
    detect_interfaces
    check_proxy_layer
    
    echo ""
    initialize_session
    configure_target
    select_scan_profile
    
    echo -e "\n${YEL}Proceed with scan? (y/n):${NC} "
    read -r confirm
    [[ ! "$confirm" =~ ^[Yy]$ ]] && { echo -e "${RED}[!] Cancelled${NC}"; exit 0; }
    
    execute_scan
    enumerate_web_services
    search_exploits
    generate_msf_resource
    assess_vulnerabilities
    generate_final_report
    
    echo -e "${GRN}[âœ“] All operations completed${NC}\n"
}

main "$@"
